# 练习3：分析bootloader进入保护模式的过程。


了解操作系统“保护模式和分段机制”和`lab1/boot/bootasm.S`源码(主要在16-56行)

了解如何从实模式切换到保护模式,需要了解：
  * 为何开启A20，以及如何开启A20
  * 如何初始化GDT表
  * 如何使能和进入保护模式
  
系统加电时，处理器处于实模式状态，为了让它进入保护模式使用完整的32位地址线以及实现更多的保护功能，需要进行一些准备，然后将CR0中PE位置位，最后处理器开始执行保护模式下32位代码。


## 1 开启第20位地址线（A20）

* 何为A20

  Intel早期8086CPU提供了20根地址线，寻址空间为0 ~ 2^20（00000H~FFFFF）的1MB内存空间，但是8086数据处理位宽为16位，无法直接寻址1MB内存空间；因此8086提供了段地址加偏移地址的地址转换机制，这样寻址空间最大为0ffff0h+0ffffh = 10ffefh（大约1088KB）

  8086在使用这套寻址机制时寻址能力大于1MB，寻址超过1MB内存时会发生回卷。在基于intel 80286CPU 计算机系统提供24根地址线，此时寻址超过1MB时系统不会再发生回卷，这样便造成了向下不兼容。

  为了保持完全的向下兼容性，IMB在计算机系统上加了个硬件逻辑，来模仿以上的回绕特征，于是出现了A20 Gate，其实是第21根地址线，在实模式下一直被拉低，寻址超过1MB时，也会回卷。这样就能够向下兼容

* 为何开启A20

  在80286、80386以后，地址线来到了24根和32根，同时也提供了保护模式，如果A20一直置0的话，便无法寻到所有的地址空间，

  所以在保护模式中或者实模式时需要访问高端内存区，均需要将A20地址线开启

  总而言之，A20地址线并不是打开保护模式的关键，只是在保护模式下，不打开A20地址线，则无法访问到所有的内存：
   
   * 用于80286与8086兼容
   * 用于80286处于实模式下时，防止用户程序访问到100000h~10FFEFh之间的内存（高端内存）
   * 8086模式，A20关闭的情况下，访问超过1MB内存时，会自动回卷
   * 8086模式下，A20打开的情况下，访问超过1MB内存，就真实的访问
   * 保护模式下，A20关闭（始终为0），则用户的地址只能是：0 - (1MB-1), 2 - (3MB-1), 4 - (5MB-1)，我们可以这样设想，A20为个位数（以1MB为单位），如果它始终为0，你永远不可能让这个数变成奇数。
   * 保护模式下，A20开启，则可以访问全地址，没有奇偶MB的问题。
 
 
 
 

* 如何开启A20

  在开启A20之前，BIOS还做了很多事:关中断、清除方向标志，给各个数据段清零。
  
  `bootasm.S`中开始A20的方法是：
  
  1. 等待直到8042不忙(即8042输入的缓冲区为空)
  2. 向8042控制端口写入写P2端口命令（`0xd1`）
  3. 等待直到8042不忙
  4. 向8042数据端口写入`0xdf`来打开A20

总之，即通过将键盘控制器上的A20线置于高电位，全部32条地址线可用， 可以访问4G的内存空间。

  
## 2. 配置全局描述符表（GDT）

GDT全称是Global Descriptor Table，也就是全局描述符表。在保护模式下，通过设置GDT将内存空间被分割为了一个又一个的segment(这些segment是可以重叠的)，这样就能实现不同的程序访问不同的内存空间。

由于本实验弱化对于分段机制的使用，GDT及其基址和界限的描述可以硬编码在代码中。GDT中有三个描述符：空描述符、代码段描述符以及数据段描述符。然后，用`lgdt gdtdesc`载入GDT的基址和界限即可。注意，GDT需要4字节对齐。

## 3. 开启保护模式

将CR0的PE位（第0位）置1即可开启保护模式。复位后时即进入实地址模式。注意，置1后，处理器并未立即开始执行32位代码。

## 4. 开始执行32位代码

使用远跳转指令`ljmp`，将代码段寄存器`cs`设置为新的值（代码段选择子），从而真正开始32位保护模式。

由于2.配置GDT时将代码段设置为恒等映射，同时未开启分页机制，逻辑地址和物理地址直接相等，跳转目标就是下一条指令的地址。

注意跳转后还应该将各个数据段寄存器也设置为新的值（数据段选择子）。
